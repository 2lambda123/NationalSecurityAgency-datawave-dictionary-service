<html xmlns:th="http:/>/www.thymeleaf.org">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>DATAWAVE - Data Dictionary</title>
	<!--/*
    Loads jQuery, DataTables, some CSS elements for DataTables, and executes `.dataTable()` on the HTML table in the payload.
    Pagination on the table is turned off, we do an ascending sort on the 1st column (field name), 
	and a cookie is saved in the browser that will leave the last sort in place upon revisit of the page.
	*/-->
	<link rel="stylesheet" type="text/css" href="/dictionary/css/screen.css" media="screen">
	<script type="text/javascript" th:src="@{{baseUri}/dictionary/webjars/jquery/jquery.min.js(baseUri=${@environment.getProperty('server.cdnUri')})}"></script>
	<!--/*
	jquery-ui script and css needed for allowing the table columns to be resized by the user
	*/-->
	<script type="text/javascript" src="https://code.jquery.com/ui/1.9.2/jquery-ui.js"></script>
	<link rel="stylesheet" type="text/css" href="//code.jquery.com/ui/1.9.2/themes/base/jquery-ui.css">
	<script type="text/javascript" th:src="@{{baseUri}/dictionary/webjars/datatables/js/jquery.dataTables.min.js(baseUri=${@environment.getProperty('server.cdnUri')})}"></script>
	<script type="text/javascript">
		$(document).ready(function() { 
			$('#myTable').dataTable({
				"bPaginate": false, 
				"aaSorting": [
					[0, "asc"]
				],
				"bStateSave": true
			});
			$('table th').resizable({
				handles: 'e'
			});
			$('#myTable').find("td").css("word-break", "break-word");
			// Create a new div under the filter search div. Contains the info for how the table is sorted
			function createSortedByDiv() {
				var sortedByDiv = document.createElement('div');
				const textContent = document.createTextNode('Table sorted by ');
				const sortingInfo = document.createElement('span');
				sortingInfo.setAttribute('id', 'sortedBy');
				sortedByDiv.appendChild(textContent);
				sortedByDiv.appendChild(sortingInfo);
				sortedByDiv.setAttribute('style', 'padding: 5px;');
				const tableFilterDiv = document.getElementById('myTable_filter');
				tableFilterDiv.parentNode.insertBefore(sortedByDiv, tableFilterDiv.nextSibling);
			}
			// Update the text to display which column is currently being used to sort the table and in which order
			window.updateSortingInfo = function updateSortingInfo() {
				var table = document.getElementById('myTable');
				var tableHeaders = table.getElementsByTagName('tr')[0];
				var cols = tableHeaders.children;
				for (let i = 0; i < cols.length; i++) {
					let className = cols[i].getAttribute('class');
					let header = cols[i].innerHTML;
					if (className.includes('sorting_asc')) {
						document.getElementById('sortedBy').innerHTML = `<strong>${header}</strong> in <strong>ascending</strong> order`;
						break;
					}
					else if (className.includes('sorting_desc')) {
						document.getElementById('sortedBy').innerHTML = `<strong>${header}</strong> in <strong>descending</strong> order`;
						break;
					}
				}
			}
			// Add onclick events for each of the table headers to call updateSortingInfo()
			function addOnClickEvents() {
				var table = document.getElementById('myTable');
				var tableHeaders = table.getElementsByTagName('tr')[0];
				var cols = tableHeaders.children;
				for (let i = 0; i < cols.length; i++) {
					cols[i].setAttribute('onclick', 'updateSortingInfo();');
				}
			}
			// Initial calls for inital page setup
			createSortedByDiv();
			addOnClickEvents();
			updateSortingInfo();
		});
	</script>
</head>
<body>
	<h1>Data Dictionary</h1>
	<div>
		<p style="width:60%; margin-left: auto; margin-right: auto;">
		When a value is present in the forward index types, this means that a field is indexed and informs you how your query terms will be treated 
		(e.g. text, number, IPv4 address, etc). The same applies for the reverse index types with the caveat that you can also query these fields using 
		leading wildcards. Fields that are marked as 'Index only' will not appear in a result set unless explicitly queried on. Index only fields are 
		typically composite fields, derived from actual data, created by the software to make querying easier.
		</p>
	</div>
		<table id="myTable">
			<thead>
				<tr>
					<th>FieldName</th>
					<th>Internal FieldName</th>
					<th>DataType</th>
					<th>Index only</th>
					<th>Forward Indexed</th>
					<th>Reverse Indexed</th>
					<th>Normalized</th>
					<th>Types</th>
					<th>Tokenized</th>
					<th>Description</th>
					<th>LastUpdated</th>
				</tr>
			</thead>
			<tbody>
				<tr th:each="row : ${tableContent}">
					<td th:text="${row[0]}"></td>
					<td th:text="${row[1]}"></td>
					<td th:text="${row[2]}"></td>
					<td th:text="${row[3]}"></td>
					<td th:text="${row[4]}"></td>
					<td th:text="${row[5]}"></td>
					<td th:text="${row[6]}"></td>
					<td th:text="${row[7]}"></td>
					<td th:text="${row[8]}"></td>
					<td th:text="${row[9]}"></td>
					<td th:text="${row[10]}"></td>
				</tr>
			</tbody>
		</table>
	</div>
	<br>
</body>
</html>
